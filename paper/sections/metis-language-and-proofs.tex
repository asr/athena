% % -*- root: main.tex -*-
\documentclass[../main.tex]{subfiles}
\begin{document}

% ===========================================================================

\section{Metis: Language and Proofs}
\label{sec:metis-language-and-proofs}

\verb!Metis! is an automatic theorem prover written in Standard ML for
first-order logic with equality developed by John Hurd~\cite{hurd2003first}.
As we show later this prover is suitable for proof reconstruction task since
it provides well-documented proof-objects with enough information to justify
the deduction steps.

\verb!Metis! has been integrated to \verb!Isabelle/HOL! as a macro-step reconstruction
tool for justifying proof steps (usually CNF goals) replied from other ATPs like
\verb!CVC4!, \verb!Vampire!, or \verb!Z3!.
In \cite{Farber2015}, \verb!Metis! was used to provide a tactic for
\verb!HOL Light!, this tactic challenges others like \verb!MESON! tactic or the
\verb!leanCoP! tactic that reconstructs proofs delivered by
\verb!leanCoP!~\cite{Farber2016}.

In this paper, we ported a subset of \verb!Metis!' inference rules to \verb!Agda!,
the propositional fragmented, to allow us justify step-by-step the proofs
delivered in \verb!TSTP! format generated by \verb!Metis!.

% ---------------------------------------------------------------------------

\subsection{Input and Output Language}
\label{ssec:input-and-output-language}

\textit{Input.}~The \verb!TPTP! language  --which includes the first-order
form (denoted by \verb!fof!) and clause normal form (denoted by \verb!cnf!)
formats~\cite{sutcliffe2009} -- is de
facto input standard language to encode problems for many ATPs.
The \verb!TPTP! syntax describes a well-defined grammar to handle annotated
formulas with the following form

\begin{verbatim}
language(name, role, formula).
\end{verbatim}

The \verb!language! can be \verb!fof! or \verb!cnf!. The \verb!name!
serves to identify the formula within the problem. Each formula assumes one
\verb!role!, this could be an \verb!axiom!, \verb!conjecture!,
\verb!definition!, or a \verb!hypothesis!. The formulas include Boolean
connectives (\verb!&!, \verb!|!, \verb!=>!, \verb!<=>!, $\tt\sim$) and logic
constants \verb!$true! and \verb!$false!.

For instance, we express the problem
$p\, \vdash \neg (p \wedge \neg p) \vee (q \vee \neg q)$
in \verb!TPTP! syntax as follows.

\begin{verbatim}
fof(h, axiom, p).
fof(goal, conjecture, ~ ((p & ~ p) | (q & ~ q))).
\end{verbatim}

\textit{Output.}~\verb!TSTP! language is de facto output standard language
for derivations of ATPs~\cite{sutcliffe2004tstp}.
A \verb!TSTP! derivation is a directed acyclic graph, a proof tree, where each leaf
is a formula from the \verb!TPTP! input. A node is a formula inferred from the parent
formulas. The root is the final derived formula. Such a derivation is a list of
annotated formulas with the form

\begin{verbatim}
language(name, role, formula, source [,useful info]).
\end{verbatim}

The \verb!source! field is an inference record with the following pattern
\begin{verbatim}
inference(rule, useful info, parents).
\end{verbatim}

The \verb!rule! stands for the inference name, the other fields are
auxiliary arguments or useful information to apply the inference, and
the list of parents nodes.
For instance, in Fig.~\ref{fig:metis-proof-tstp}, \verb!strip! is the name of one
of the inference and it has no arguments and only one parent node, \verb!goal!.

\begin{figure}
\begin{verbatim}
fof(a, axiom, p) .
fof(goal, conjecture, p) .
fof(subgoal_0, plain, p, inference (strip, [], [goal])) .
fof(negate_0_0, plain, ~ p, inference (negate, [], [subgoal_0])) .
fof(normalize_0_0, plain, âˆ¼ p, inference (canonicalize, [], [negate_0_0])) .
fof(normalize_0_1, plain, p, inference (canonicalize, [], [a])) .
fof(normalize_0_2, plain, $false, inference (simplify, [],
  [normalize_0_0, normalize_0_1]))
cnf(refute_0_0, plain, $false, inference (canonicalize, [], [normalize_0_2])) .
\end{verbatim}
\caption{A simple \texttt{Metis}' \texttt{TSTP} derivation for the problem $p\vdash p$.}
\label{fig:metis-proof-tstp}
\end{figure}

% ---------------------------------------------------------------------------

\subsection{Proof Terms}
\label{ssec:proof-terms}

A proof-object delivered in a \verb!Metis!' proof encodes a natural
deduction proof. Its deduction system uses six simple inference rules
(see Fig.~\ref{fig:metis-inferences}) to attempt to prove conjectures
by refutation (see. e.g. Fig.~\ref{fig:metis-example}).

\begin{figure}
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{axiom}
  \UnaryInfC{$C$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{assume $L$}
  \UnaryInfC{$L \vee \neg L$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{refl $t$}
  \UnaryInfC{$t = t$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$C$}
  \RightLabel{subst $\sigma$}
  \UnaryInfC{$\sigma\,C$}
\end{bprooftree}
\qquad
% }
\]
\[
% \scalebox{0.9}{
\begin{bprooftree}
  \AxiomC{}
  \RightLabel{equality $L$ $p$ $t$}
  \UnaryInfC{$\neg (L[p] = t) \vee \neg L \vee L[ p \mapsto t]$}
\end{bprooftree}
\qquad
\begin{bprooftree}
  \AxiomC{$L \vee C$}
  \AxiomC{$\neg L \vee D$}
  \RightLabel{resolve $L$}
  \BinaryInfC{$C \vee D$}
\end{bprooftree}
% }
\]
\caption{Inference rules of the \texttt{Metis} prover.}
\label{fig:metis-inferences}
\end{figure}

These proofs are directed acyclic graphs, trees of refutations. Each node stands
for an application of an inference rule and the
leaves in the tree represent formulas in the given problem. Each node is
labeled with a name of the inference rule
(e.g. \verb!canonicalize! in Fig.~\ref{fig:metis-example}). Each
edge links a premise with one conclusion. The proof graphs have in their
root the conclusion $\bot$ since \verb!Metis! delivers proof by refutation.

% \begin{figure}
% \centering
% \begin{bprooftree}
%   \centering\tt
%   \AxiomC{}
%   \RightLabel{\scriptsize negate}
%   \UnaryInfC{$\neg p$}
%   \RightLabel{\scriptsize strip}
%   \UnaryInfC{$\neg p$}
%   \AxiomC{}
%   \RightLabel{\scriptsize axiom}
%   \UnaryInfC{$p$}
%   \RightLabel{\scriptsize canonicalize}
%   \UnaryInfC{$p$}
%   \RightLabel{\scriptsize simplify}
%   \BinaryInfC{$\bot$}
%   \RightLabel{\scriptsize canonicalize}
%   \UnaryInfC{$\bot$}
% \end{bprooftree}
% % \caption{The \verb!Metis!' refutation tree for $p \vdash p$ from the
% % derivation in Fig.~\ref{fig:metis-proof-tstp}}
% \label{fig:metis-example}
% \end{figure}

% ---------------------------------------------------------------------------

\subsection{Proof Rules}
\label{ssec:proof-rules}

Despite the six simple rules in the \verb!Metis!' logic
kernel (see~Fig. \ref{fig:metis-inferences}), we found in \verb!TSTP!
derivations for CPL problems other inference rules.
They are \verb!canonicalize!, \verb!conjunct!, \verb!negate!, \verb!simplify!,
\verb!strip! and \verb!resolve!. We briefly review each of these rules
following no order except maybe by their frequency in the \verb!TSTP! derivations.

% ...........................................................................

\textit{Splitting}.
To prove a goal, \verb!Metis! splits the goal into disjoint cases. This
process produces a list of new subgoals, the conjunction of these subgoals
implies the goal as we show later in subsection~\ref{ssec:emulating-inferences}.
Then, a proof of the goal becomes in smaller proofs, one
refutation for each subgoal. These subgoals are introduced in the \verb!TSTP!
derivation with the \verb!strip! inference rule.

\begin{verbatim}
fof(goal, conjecture, p & r & q).
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(subgoal_1, plain, p => r, inference(strip, [], [goal])).
fof(subgoal_2, plain, (p & r) => q, inference(strip, [], [goal])).
\end{verbatim}

% ...........................................................................

\textit{Clausification.} The \verb!clausify! rule transforms a
propositional formula in clausal normal form or CNF,
a conjunction of clauses. Where a clause is the disjunction of zero or
more literals and a literal is an atom (positive literal) or a negation of an
atom (negative literal). This conversion is not unique and \verb!Metis! performs
this transformation using its own criteria.

% ...........................................................................

\textit{Normalization.}
\verb!Metis! uses the \verb!canonicalize! rule to normalize a
propositional formula that comes from an axiom or a definition.
It often converts the formula in one of its normal form,
the conjunctive normal form,%as \verb!clausify! does
the negative normal form or the disjunctive normal form.
Posterior, this rule simplifies the formula with some definitions, applying
recursively on the structure's formula conjunctions and disjunctions simplifications
to remove tautologies
(see Fig.~\ref{fig:conjunctive-disjunctive-simplification} with a list
of these theorems. We had assumed the commutative property for conjunction and
disjunction connectives).

\begin{figure}
\[%\scalebox{0.9}{
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \bot$}
    \UnaryInfC{$\bot$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \top$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \neg \varphi$}
    \UnaryInfC{$\bot$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \wedge \varphi$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
%}
\]

\[%\scalebox{0.9}{
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \bot$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \top$}
    \UnaryInfC{$\top$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \neg \varphi$}
    \UnaryInfC{$\top$}
  \end{bprooftree}
  \qquad
  \begin{bprooftree}
    \AxiomC{$\varphi \vee \varphi$}
    \UnaryInfC{$\varphi$}
  \end{bprooftree}
%}
\]
% \caption{Some rules of \verb!canonicalize! inference.}
\label{fig:conjunctive-disjunctive-simplification}
\end{figure}

% ...........................................................................

\textit{Resolution.} The \verb!resolve! rule (see, for example,
Fig.~\ref{fig:resolve-inference}) is the resolution
theorem with two argument, the positive literal for resolution and two
formulas from their own derivations. The positive literal $p$ must occur in
the first formula of the input and the negative literal must occur in the second
formula of the input
(see the resolve rule in \verb!Metis!' logic core in
Fig.~\ref{fig:metis-inferences}).

\begin{verbatim}
cnf(refute_0_0, plain, p | q, inference(canonicalize, [], [normalize_0_0])).
cnf(refute_0_1, plain, ~ p, inference(canonicalize, [], [normalize_0_4])).
cnf(refute_0_2, plain, q,
  inference(resolve, [$cnf(p)], [refute_0_0, refute_0_1])).
\end{verbatim}

% ...........................................................................

\textit{Splitting a conjunct.}
The \verb!conjunct! rule extracts from a conjunction one of its conjuncts, it is
a generalization of the projection rules for the conjunction connective as
we can see in the following \verb!TSTP! derivation.

\begin{verbatim}
fof(normalize_1, plain, p & q & r, inference(canonicalize, [], [x])).
fof(normalize_2, plain, q, inference(conjunct, [], [normalize_1])).
\end{verbatim}

\textit{Negate.}
Each subgoal proof is a refutation, thereby each proof assumes
the negation of its subgoal. The \verb!negate! rule
introduces the negation of a subgoal that results
after applies the \verb!strip! inference to the goal.

\begin{verbatim}
fof(subgoal_0, plain, p, inference(strip, [], [goal])).
fof(negate_0_0, plain, ~ p, inference(negate, [], [subgoal_0])).
\end{verbatim}

% ...........................................................................

\textit{Simplification.} %abbreviate formulas
The \verb!simplify! rule is an $n$-ary rule that performs simplification
of definitions. This rule transverses a list of formulas by
applying different theorems (e.g.\emph{modus pones}, \emph{modus tollens},
or \emph{disjunctive syllogism}) including the list of theorems used by
\verb!canonicalize! in Fig.~\ref{fig:conjunctive-disjunctive-simplification}
and the resolution theorem of \verb!resolve! rule.
Moreover, many things happen inside this \verb!Metis!' procedure and
it is fairly complex to grasp it completely.

\end{document}